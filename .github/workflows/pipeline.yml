name: CD - Production Deployment

on:
  push:
    branches:
      - main

env:
  DOCKERHUB_USERNAME: linhx021
  BACKEND_IMAGE: linhx021/fbads-backend
  FRONTEND_IMAGE: linhx021/fbads-frontend
  GCP_HOST: 34.126.190.19
  GCP_USER: linhnh
  DEPLOY_PATH: /home/linhnh/ads-creative-content

jobs:
  test:
    name: Setup environment
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Validate Flyway Migrations
        run: |
          cd backend

          # Check migration file naming convention
          echo "=== Checking migration file naming convention ==="
          invalid_files=$(find src/main/resources/db/migration -type f ! -name 'V*__*.sql' -name '*.sql' 2>/dev/null | wc -l)
          if [ "$invalid_files" -gt 0 ]; then
            echo "❌ ERROR: Found migration files with invalid naming:"
            find src/main/resources/db/migration -type f ! -name 'V*__*.sql' -name '*.sql'
            exit 1
          fi
          echo "✅ All migration files follow naming convention"

          # List all migrations
          echo ""
          echo "=== Current migration files ==="
          ls -1 src/main/resources/db/migration/V*.sql 2>/dev/null || echo "No migrations found"

          # Validate SQL syntax (basic check)
          echo ""
          echo "=== Validating SQL syntax ==="
          for file in src/main/resources/db/migration/V*.sql; do
            if [ -f "$file" ]; then
              echo "Checking $(basename $file)..."
              if ! grep -q ";" "$file"; then
                echo "⚠️  WARNING: $file may be missing semicolons"
              fi
            fi
          done
          echo "✅ SQL syntax validation completed"


  build:
    name: Build and push images
    runs-on: ubuntu-latest
    needs: [test]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Get short SHA
        id: vars
        run: echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          no-cache: true  # Force fresh build to ensure latest code
          tags: |
            ${{ env.BACKEND_IMAGE }}:latest
            ${{ env.BACKEND_IMAGE }}:${{ steps.vars.outputs.sha_short }}

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          build-args: |
            VUE_APP_API_BASE_URL=/api
            VUE_APP_ENVIRONMENT=production
            BUILD_TIMESTAMP=$(date +%s)
          tags: |
            ${{ env.FRONTEND_IMAGE }}:latest
            ${{ env.FRONTEND_IMAGE }}:${{ steps.vars.outputs.sha_short }}
          cache-from: type=registry,ref=${{ env.FRONTEND_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.FRONTEND_IMAGE }}:buildcache,mode=max

  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs: [build]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.GCP_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.GCP_HOST }} >> ~/.ssh/known_hosts

      - name: Pre-deployment Migration Safety Check
        run: |
          ssh -o StrictHostKeyChecking=no ${{ env.GCP_USER }}@${{ env.GCP_HOST }} << 'ENDSSH'
            set -e
            echo "=== Pre-Deployment Migration Safety Check ==="

            cd ${{ env.DEPLOY_PATH }}

            # Check if database is accessible
            echo "1. Checking database connectivity..."
            if docker-compose exec -T postgres pg_isready -U postgres > /dev/null 2>&1; then
              echo "✅ Database is accessible"
            else
              echo "❌ ERROR: Database is not accessible!"
              exit 1
            fi

            # Create database backup
            echo ""
            echo "2. Creating database backup..."
            BACKUP_DIR="/tmp/db_backups"
            mkdir -p "$BACKUP_DIR"
            BACKUP_FILE="$BACKUP_DIR/backup_$(date +%Y%m%d_%H%M%S).sql"

            if docker-compose exec -T postgres pg_dump -U postgres fbadsautomation > "$BACKUP_FILE" 2>/dev/null; then
              BACKUP_SIZE=$(du -h "$BACKUP_FILE" | cut -f1)
              echo "✅ Database backed up to $BACKUP_FILE ($BACKUP_SIZE)"

              # Keep only last 10 backups
              ls -t "$BACKUP_DIR"/backup_*.sql 2>/dev/null | tail -n +11 | xargs rm -f 2>/dev/null || true
            else
              echo "⚠️  WARNING: Database backup failed!"
            fi

            # Check current migration status
            echo ""
            echo "3. Checking current migration status..."
            docker-compose exec -T postgres psql -U postgres fbadsautomation -c "SELECT version, description, installed_on, success FROM flyway_schema_history ORDER BY installed_rank DESC LIMIT 5;" 2>/dev/null || echo "Could not query migration history"

            echo ""
            echo "=== Pre-deployment checks completed ==="
          ENDSSH

      - name: Deploy to GCP server
        run: |
          ssh -o StrictHostKeyChecking=no ${{ env.GCP_USER }}@${{ env.GCP_HOST }} << 'ENDSSH'
            set -e

            echo "Starting deployment..."
            cd ${{ env.DEPLOY_PATH }}

            # Pull latest code
            echo "Pulling latest code from GitHub..."
            git fetch origin
            git reset --hard origin/main

            # Login to Docker Hub
            echo "Logging in to Docker Hub..."
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin

            # Pull latest images
            echo "Pulling latest Docker images..."
            docker pull ${{ env.BACKEND_IMAGE }}:latest
            docker pull ${{ env.FRONTEND_IMAGE }}:latest

            # Health check before deployment
            echo "Checking current service health..."
            BACKEND_HEALTHY=$(docker inspect --format='{{.State.Health.Status}}' fbads-backend 2>/dev/null || echo "none")
            echo "Current backend health: $BACKEND_HEALTHY"

            # Clean up old backend images to avoid tag conflicts
            echo "Cleaning up old backend images..."
            docker images ${{ env.BACKEND_IMAGE }} --format "{{.ID}} {{.Tag}}" | grep "<none>" | awk '{print $1}' | xargs -r docker rmi -f || true

            # Force recreate backend with new image
            echo "Force recreating backend container with latest image..."
            docker-compose up -d --force-recreate --no-deps backend

            # Wait for new backend to be healthy
            echo "Waiting for backend to be healthy..."
            TIMEOUT=120
            ELAPSED=0
            while [ $ELAPSED -lt $TIMEOUT ]; do
              BACKEND_HEALTHY=$(docker inspect --format='{{.State.Health.Status}}' fbads-backend 2>/dev/null || echo "none")
              if [ "$BACKEND_HEALTHY" = "healthy" ]; then
                echo "Backend is healthy!"
                break
              fi
              echo "Waiting... (${ELAPSED}s/${TIMEOUT}s)"
              sleep 5
              ELAPSED=$((ELAPSED + 5))
            done

            if [ $ELAPSED -ge $TIMEOUT ]; then
              echo "Backend failed health check! Check logs with: docker logs fbads-backend"
              exit 1
            fi

            # Update frontend
            echo "Updating frontend..."
            docker-compose up -d --force-recreate --no-deps frontend

            # Wait for frontend to be ready
            echo "Waiting for frontend..."
            sleep 10

            # Final health check
            echo "Final health check..."
            docker-compose ps

            # Cleanup old images
            echo "Cleaning up old Docker images..."
            docker image prune -af --filter "until=24h" || true

            echo "Deployment completed successfully!"
          ENDSSH

      - name: Verify deployment
        run: |
          echo "Verifying deployment..."

          # Wait a bit for services to stabilize
          sleep 15

          # Check backend health
          BACKEND_STATUS=$(curl -f -s -o /dev/null -w "%{http_code}" https://linhnh.site/api/actuator/health || echo "000")

          if [ "$BACKEND_STATUS" = "200" ]; then
            echo "Backend is responding correctly (HTTP $BACKEND_STATUS)"
          else
            echo "Backend health check failed (HTTP $BACKEND_STATUS)"
            exit 1
          fi

          # Check frontend
          FRONTEND_STATUS=$(curl -f -s -o /dev/null -w "%{http_code}" https://linhnh.site || echo "000")

          if [ "$FRONTEND_STATUS" = "200" ]; then
            echo "Frontend is responding correctly (HTTP $FRONTEND_STATUS)"
          else
            echo "Frontend health check returned HTTP $FRONTEND_STATUS"
          fi

      - name: Send deployment notification
        if: always()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 587
          username: ${{ secrets.GMAIL_USERNAME }}
          password: ${{ secrets.GMAIL_APP_PASSWORD }}
          subject: |
            ${{ job.status == 'success' && '✅' || '❌' }} Deployment ${{ job.status }} - ads-creative-content
          to: ${{ secrets.NOTIFY_EMAIL }}
          from: GitHub Actions <${{ secrets.GMAIL_USERNAME }}>
          body: |
            Deployment Status: ${{ job.status }}

            Repository: ${{ github.repository }}
            Branch: ${{ github.ref_name }}
            Commit: ${{ github.sha }}
            Author: ${{ github.actor }}

            Workflow: ${{ github.workflow }}
            Run ID: ${{ github.run_id }}

            ${{ job.status == 'success' && 'All services are running and healthy!' || '❌ Deployment failed! Please check the logs.' }}

            View run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}


  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && github.event_name == 'workflow_dispatch'
    needs: [deploy]

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.GCP_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.GCP_HOST }} >> ~/.ssh/known_hosts

      - name: Perform rollback
        run: |
          ssh -o StrictHostKeyChecking=no ${{ env.GCP_USER }}@${{ env.GCP_HOST }} << 'ENDSSH'
            echo "Performing rollback..."
            cd ${{ env.DEPLOY_PATH }}

            # Pull previous images
            docker pull ${{ env.BACKEND_IMAGE }}:previous || echo "No previous backend image"
            docker pull ${{ env.FRONTEND_IMAGE }}:previous || echo "No previous frontend image"

            # Restart with previous images
            docker-compose down
            docker-compose up -d

            echo "Rollback completed"
          ENDSSH
